/*
 * Overloading of the assignment operator ("=") & the importance of "deep copy"
 *
 *
 *
 * 1. The assignment operator can only be overloaded as a member function!!!
 *
 *
 * 2. Being used in the assignment between different types.
 *    Should be the basis of many C++ STL Class, e.g., the std::string class.
 *    -- char name[] = "peter";
 *    -- std::string str = name;
 *
 *
 * 3. The return type of the operator= function:
 *
 *	  A principle -> keeping the properties of the original '=' operator
 *	  i.e. something like a=b=c / (a=b)=c, if we use void as return type here,
 *	  such expression is not allowed, which is against the property of original '=',
 *	  so we should better use type& here.
 *
 *	  The return type doesn't have any effects on single assignment like "a=b",
 *	  it will be only important if we use the assignment expression as arguments ->
 *	  -- foo(a=b);
 *	  -- c = (a=b);
 *	  -- (a=b) = c;
 *	  So again, better use type& to keep the original property of "=", especially when doing copy.
 *
 *	  For assignment between different types, should consider the specific application of the overloading.
 *	  -- char* Mystring::operator= (char* str);
 *	  -> Mystring a; Mystring b; Char c[];
 *	     a=(b=c);
 *	  -- Mystring& Mystring::operator= (char* str) {...; return *this;}
 *	  -> Mystring a; char b[]; char c[];
 *	     (a=b)=c;
 *
 *
 * 4. "deep" vs. "shallow" copy (functional vs. naive):
 *
 *    The default copy operation or copy constructor in C++ copies naively all the bytes of an object
 *    to another one ("shallow" or naive copy) !!! This would lead to severe problem sometimes,
 *    especially it is not good to copy one pointer directly to another.
 *
 *    For example, after naive copy, the pointer members of two object will point to the same address,
 *    and later when they are both destructed the same memory entry may be released twice -> disaster!!!
 *    -- a=b; ~Mystring() { delete[] str; }
 *
 *    What we can do here is to implement manually an operator= or copy constructor and define the behavior
 *    of the copy. E.g. we can just copy the content of one pointer member to another. this is the so called
 *    "deep" (functional) copy !!!
 *
 *
 * 5. Something about the strcpy in string.h:
 *
 *    To avoid overflows, the size of the array pointed by destination shall be long enough to
 *    contain the same C string as source (including the terminating null character), and should
 *    not overlap in memory with source. ---- http://www.cplusplus.com/reference/cstring/strcpy/
 *
 *    So we need such codes to ensure successful copy ->
 *    -- if(str) delete [] str;        // empty destination
 *    -- str = new char[strlen(s)+1];  // allocate memory to destination, +1 for the terminator: /0
 *    -- strcpy(str, s);               // copy the string
 */

#include <iostream>
#include <cstring> // old C stuff, just for learning


class Mystring
{

private:
	char* str;

public:

	/*
	 * you can not delete a normal array, only the one generated by the "new" keyword.
	 * And the destructor will automatically release the content even if you do not write explicitly in the destructor
	 * and then shitty "CORE DUMPED" comes!!!!!!!
	 */
	Mystring(const char* s) {  str = new char[strlen(s)+1]; strcpy(str,s); }
	Mystring(): str(NULL) {}
	~Mystring() { /*if(str) delete[] str;*/ }            // release the char string in destructor
	void StrGet() { std::cout << str << std::endl; }    // get str member

	Mystring& operator=(const char* s);                 // assignment from char* string -> type& style, alternative -> char*
	Mystring& operator=(const Mystring& s);             // "deep" copy -> type& style
};


Mystring& Mystring::operator=(const char* s)
{
	if(str)
		delete[] str;

	if(s)
	{
		str = new char[strlen(s)+1];
		strcpy(str,s);
	}
	else
		str = NULL;

	return *this;
}


/*
 * what the crap!!!
 * private member of another object can be accessed in the member function!!!
 */

Mystring& Mystring::operator=(const Mystring& s)
{
	// avoid error comes with expression like s=s;
	if(str == s.str )
		return *this;
    if(str)
    	delete[] str;
	if(s.str)
	{
		str = new char[strlen(s.str)+1];
		strcpy(str,s.str);
	}
	else
		str = NULL;

	return *this;
}



int main()
{
	Mystring name0("Jeremie");
	Mystring name1("Maximilian");
	Mystring name2,name3,name4,name5,name6,name7,name8;

	(name2 = "Maximilian") = "Alexander";
	(name3 = name1) = name2;
	name5 = name4 = name0;
	name7 = name6 = "Branton";

    name0.StrGet();
    name1.StrGet();
    name2.StrGet();
    name3.StrGet();
    name4.StrGet();
    name5.StrGet();
    name6.StrGet();
    name7.StrGet();
    return 0;
}

